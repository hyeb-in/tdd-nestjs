# Node.js에서의 동시성 제어 

## 1. 동시성 문제와 동시성 제어란?

### 1-1. 동시성 문제
동시성 문제는 여러 작업이 동시에 실행되거나 작업의 순서가 뒤섞이면서 발생하는 문제를 의미한다. 이러한 문제는 주로 하나의 공유 자원(데이터베이스, 메모리, 파일 등)에 여러 프로세스나 스레드가 동시에 접근하여 데이터를 읽거나 수정할 때 발생할 수 있다. 예를 들어, 두 개의 작업이 동일한 데이터를 동시에 업데이트하려고 할 때, 작업의 순서가 보장되지 않으면 데이터의 **정합성(Consistency)**이 깨질 수 있다.

### 1-2. 동시성 제어 
동시성 제어는 여러 작업이 동시에 실행되더라도 데이터의 **일관성**을 보장하고, 공유 자원에 대한 접근을 관리하는 다양한 기법을 의미한다. 이를 통해 여러 작업이 동일한 자원에 동시에 접근할 때 발생할 수 있는 충돌이나 데이터 무결성 문제를 방지할 수 있다.


## 2. 현재 구현 상황

### 2-1. 메모리 기반 저장소
현재, 데이터베이스를 사용하지 않고 **메모리 기반 저장소**(`UserPointTable` 및 `PointHistoryTable`)를 사용하여 사용자의 포인트 데이터를 관리하고 있다. 이 저장소는 `Promise`를 사용하여 비동기적으로 데이터를 조회하고 삽입하며, 각 요청에 대하여 랜덤한 딜레이를 적용해 실제 데이터베이스와 유사한 동작을 모방하고 있다.

### 2-2. 동시성 제어 `SequentialTaskHandler`
사용자가 동시에 여러 요청을 보낼 경우, 이를 순차적으로 처리하기 위해 **`SequentialTaskHandler`** 클래스를 사용하고 있다. 이 클래스는 각 사용자에 대한 작업을 `Promise` 체인으로 연결하여, 각 작업이 완료된 후에 다음 작업이 처리되도록 보장한다. 이 방식은 사용자별로 요청을 순차적으로 처리하도록 보장하지만, 이는 **메모리 기반의 단일 서버**에서만 동작이 보장된다.


### 2-3. 테스트 코드 
테스트 코드를 이용해 충전, 사용, 충전과 사용 세가지 케이스에 대해 다수의 요청을 동시에 보내, 요청이 순차적으로 처리되는지 검증하고 있다. 



## 3. Node.js에서의 동시성 문제 
### 3-1. Node.js의 싱글스레드 
Node.js는 싱글스레드 이벤트 루프 기반으로 동작한다. 즉, 모든 자바스크립트 코드는 단일 스레드에서 실행된다. 그러나 I/O 작업, 네트워크 요청, 파일 읽기/쓰기 등 시간이 오래 걸리는 작업들은 비동기적으로 처리되며, 이러한 작업이 완료되면 이벤트 루프가 해당 작업의 콜백을 실행한다. 이는 동시에 여러 작업을 처리하는 것처럼 보이지만, 실제로는 작업 간의 순서가 예측할 수 없이 바뀌어 동시성 문제가 발생할 수 있다.


## 4. 실제 환경에서의 동시성 제어 
현재 구현된 `SequentialTaskHandler`는 사용자별로 작업이 순차적으로 처리되기 때문에, 각 사용자의 포인트 충전 작업은 충돌 없이 처리된다. 그러나 이는 단일 서버와 메모리 기반의 환경에서만 유효한 방법이다.
### 4-1. 분산 서버 환경
실제 배포된 환경에서는 여러 서버 인스턴스가 분산되어 운영된다. 이 경우, 사용자의 요청은 여러 서버로 분산될 수 있으며, 각 서버는 자신의 메모리에 사용자 데이터를 저장한다. 따라서, 분산 서버 환경에서 동시성 제어를 위해서는 중앙 집중식 데이터 저장소(데이터베이스)나 분산 락 메커니즘이 필요하다.

예를 들어, Redis 같은 외부 캐시 서버를 사용해 각 작업에 대한 분산 락을 설정하거나, 데이터베이스의 트랜잭션을 통해 동시성을 제어할 수 있다. 그렇지 않으면, 여러 서버에서 동일한 사용자의 포인트를 동시에 수정하는 경우가 발생할 수 있다.

## 5. 락의 종류
### 5-1. 분산락
`분산 락(Distributed Lock)`은 여러 서버 인스턴스나 프로세스가 분산된 환경에서 하나의 자원에 대해 동시에 접근하지 못하도록 제어하는 기법을 의미한다. 이를 통해 여러 노드가 동일한 자원에 대해 중복되거나 충돌하는 작업을 방지할 수 있다. 분산 시스템에서는 여러 서버가 동시에 동일한 자원(예: 데이터베이스, 파일 시스템 등)에 접근할 가능성이 있기 때문에, 자원에 대한 동시성 문제를 방지하기 위해 분산 락이 사용된다.

## 5-2. 비관적락
`비관적 락(Pessimistic Lock)`은 데이터에 대한 충돌이 자주 발생할 것이라고 가정하고, 데이터를 수정하기 전에 먼저 해당 자원에 락을 거는 방식이다. 이 락을 거는 동안에는 다른 작업이 해당 자원에 접근할 수 없으며, 락을 해제하기 전까지는 다른 트랜잭션이 해당 데이터를 읽거나 수정할 수 없게 된다. 이 방식은 데이터 충돌을 확실하게 방지하지만, 락을 오랫동안 유지할 경우 다른 작업이 지연될 수 있는 단점이 있다.

## 5-3. 낙관적락
`낙관적 락(Optimistic Lock)`은 데이터 충돌이 드물 것이라고 가정하고, 데이터를 수정하기 전에 락을 걸지 않는 방식이다. 대신, 데이터 수정이 완료되기 전에 데이터의 상태를 확인하여, 데이터가 수정되었는지 여부를 검사한다. 만약 수정 중에 다른 트랜잭션이 데이터를 변경했다면, 충돌이 발생했음을 인식하고 작업을 취소하거나 재시도한다.

낙관적 락은 주로 데이터베이스에서 버전(Version) 또는 타임스탬프를 활용해 구현된다. 데이터를 읽은 후 수정할 때, 해당 데이터의 버전이 변경되지 않았는지 확인하고, 버전이 일치하면 수정 작업을 완료한다. 반대로 버전이 변경된 경우, 충돌이 발생한 것으로 간주하고 수정 작업을 실패시킨다.
